"""Configuration loader for the Result GUI module.

This module provides a typed configuration data model and utilities to load and
validate the application's YAML configuration file. It additionally supports
loading PostgreSQL connection settings from a .env file and OS environment
variables with explicit, documented precedence.

Precedence summary:
    1. A boolean flag in YAML, ``user_environment_db_config`` (default: True),
       controls whether DB settings prefer environment variables vs YAML.
    2. When ``user_environment_db_config`` is True (environment-first):
       - Use .env/OS environment values when available; otherwise fall back to
         YAML values.
    3. When ``user_environment_db_config`` is False (YAML-first):
       - Use YAML values when provided and non-empty; otherwise fall back to
         .env/OS environment values.
    4. .env values are loaded from the repository root (searching upward from this module);
       if not found, a local ".env" next to config.yaml is used. OS environment variables override the .env file.

Environment variable mapping:
    POSTGRES_HOST                  -> db_host
    POSTGRES_PORT                  -> db_port
    POSTGRES_USER                  -> db_user
    POSTGRES_PASSWORD              -> db_password
    POSTGRES_DB                    -> db_name
    POSTGRES_TABLE_NAME            -> results_table
    POSTGRES_APP_USER_TABLE_NAME   -> app_user_table (table name only; schema via auth_db_schema)

Example:
    >>> from pathlib import Path
    >>> cfg = load_config(Path('config.yaml'))
    >>> cfg.db_host
    'localhost'
"""
from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, Optional
import os
import secrets

import yaml


@dataclass(frozen=True)
class AppConfig:
    """Application configuration data structure.

    Attributes:
        use_csv: If True, results are read from a CSV file. If False, results
            are read from a PostgreSQL table.
        csv_path: Filesystem path to the CSV file with debug results. Required
            when ``use_csv`` is True.
        db_host: PostgreSQL host for reading results and authentication.
        db_port: PostgreSQL port number.
        db_user: PostgreSQL username.
        db_password: PostgreSQL password.
        db_name: PostgreSQL database name.
        results_table: Name of the PostgreSQL table containing results. Required
            when ``use_csv`` is False.
        auth_db_schema: Schema name (like a folder) where the users table is
            stored; defaults to "public".
        app_user_table: Table name (no schema) for storing application users;
            defaults to "users". The fully-qualified table becomes
            ``{auth_db_schema}.{app_user_table}``.
        web_port: TCP port that the Flask app will bind to when run directly.
        debug_mode: Whether to enable Flask debug mode when run directly.
        secret_key: Secret key used for securely signing the session cookie.
        user_environment_db_config: If True, prefer .env/OS environment values
            for DB config; if False, prefer YAML values.
        enable_2f_authentication: Global switch to require TOTP-based 2-factor
            authentication after password verification. When True, users will
            be prompted for a one-time code generated by an authenticator app.
    """

    use_csv: bool
    csv_path: Optional[str]

    db_host: str
    db_port: int
    db_user: str
    db_password: str
    db_name: str

    results_table: Optional[str]
    auth_db_schema: str
    app_user_table: str

    web_port: int
    debug_mode: bool

    secret_key: str
    user_environment_db_config: bool
    enable_2f_authentication: bool

    @property
    def csv_path_resolved(self) -> Optional[Path]:
        """Return the resolved Path for the CSV if configured.

        Returns:
            The resolved ``Path`` to the CSV file when ``use_csv`` is True and
            ``csv_path`` is provided; otherwise ``None``.
        """
        if self.use_csv and self.csv_path:
            return Path(self.csv_path).expanduser().resolve()
        return None


# ----------------------------
# Parsing helpers
# ----------------------------

def _ensure_bool(value: Any, key: str) -> bool:
    """Coerce a value to ``bool`` with validation.

    Args:
        value: The input value to coerce.
        key: The config key for error reporting.

    Returns:
        The coerced boolean value.

    Raises:
        ValueError: If the value cannot be interpreted as boolean.
    """
    if isinstance(value, bool):
        return value
    if isinstance(value, str):
        val = value.strip().lower()
        if val in {"true", "1", "yes", "y"}:
            return True
        if val in {"false", "0", "no", "n"}:
            return False
    raise ValueError(f"Invalid boolean for '{key}': {value!r}")


def _get_optional_str(data: Dict[str, Any], key: str, default: Optional[str] = None) -> Optional[str]:
    """Fetch an optional string from a mapping.

    Args:
        data: The mapping containing configuration values.
        key: The key to fetch.
        default: Optional default to return if key is missing or empty.

    Returns:
        The string value or ``default``.
    """
    if key not in data:
        return default
    val = str(data[key]).strip()
    return val if val else default


def _get_int_from_any(value: Any, key: str) -> int:
    """Coerce a value to int with validation.

    Args:
        value: The input value to coerce.
        key: The config key for error reporting.

    Returns:
        The integer value.

    Raises:
        ValueError: If the value is not an integer.
    """
    try:
        return int(value)
    except (TypeError, ValueError) as exc:
        raise ValueError(f"Config key '{key}' must be an integer") from exc


def _generate_secret_key() -> str:
    """Generate a cryptographically secure secret key for Flask sessions.

    Returns:
        A URL-safe random string suitable for use as ``SECRET_KEY``.
    """
    return secrets.token_urlsafe(32)


def _read_yaml(path: Path) -> Dict[str, Any]:
    """Read a YAML file and return a mapping.

    Args:
        path: Path to the YAML configuration file.

    Returns:
        A dictionary representing the parsed YAML content.

    Raises:
        FileNotFoundError: If the file does not exist.
        ValueError: If the YAML content is invalid or not a mapping.
    """
    if not path.exists():
        raise FileNotFoundError(f"Configuration file not found: {path}")
    with path.open("r", encoding="utf-8") as f:
        try:
            data = yaml.safe_load(f) or {}
        except yaml.YAMLError as exc:
            raise ValueError(f"Invalid YAML in config file {path}: {exc}") from exc
    if not isinstance(data, dict):
        raise ValueError(f"Configuration file must define a mapping at top-level: {path}")
    return data


def _parse_dotenv(env_path: Path) -> Dict[str, str]:
    """Parse a simple .env file into a dictionary.

    Only handles lines of the form KEY=VALUE, ignoring empty lines and comments
    starting with '#'. Does not support advanced quoting/escaping rules beyond
    stripping surrounding quotes.

    Args:
        env_path: Path to the .env file.

    Returns:
        A mapping of environment variable keys to values.
    """
    if not env_path.exists():
        return {}
    result: Dict[str, str] = {}
    with env_path.open("r", encoding="utf-8") as f:
        for raw in f:
            line = raw.strip()
            if not line or line.startswith("#"):
                continue
            if "=" not in line:
                continue
            k, v = line.split("=", 1)
            key = k.strip()
            val = v.strip().strip('"').strip("'")
            if key:
                result[key] = val
    return result


def _find_env_file(start_dir: Path, filename: str = ".env") -> Optional[Path]:
    """Locate an environment file by walking upward toward the repository root.

    The search begins at ``start_dir`` and ascends parent directories until a file
    named ``filename`` is found or the filesystem root is reached.

    Args:
        start_dir: Directory to start searching from.
        filename: Environment filename to locate (default: ".env").

    Returns:
        Optional[Path]: The first matching path if found; otherwise ``None``.
    """
    cur = start_dir
    try:
        while True:
            candidate = cur / filename
            if candidate.exists():
                return candidate
            if cur.parent == cur:
                break
            cur = cur.parent
    except Exception:
        return None
    return None


def _env_to_config_keys(env: Dict[str, str]) -> Dict[str, Any]:
    """Map .env/OS environment variables to internal config keys.

    Args:
        env: Mapping of environment variables.

    Returns:
        Mapping for config keys with values possibly as strings; types will be
        normalized later.
    """
    out: Dict[str, Any] = {}
    if "POSTGRES_HOST" in env:
        out["db_host"] = env["POSTGRES_HOST"].strip()
    if "POSTGRES_PORT" in env:
        out["db_port"] = env["POSTGRES_PORT"].strip()
    if "POSTGRES_USER" in env:
        out["db_user"] = env["POSTGRES_USER"].strip()
    if "POSTGRES_PASSWORD" in env:
        out["db_password"] = env["POSTGRES_PASSWORD"].strip()
    if "POSTGRES_DB" in env:
        out["db_name"] = env["POSTGRES_DB"].strip()
    if "POSTGRES_TABLE_NAME" in env:
        out["results_table"] = env["POSTGRES_TABLE_NAME"].strip()
    if "POSTGRES_APP_USER_TABLE_NAME" in env:
        out["app_user_table"] = env["POSTGRES_APP_USER_TABLE_NAME"].strip()
    return out


def load_config(path: Path) -> AppConfig:
    """Load and validate the application configuration.

    This function loads YAML configuration from ``path`` and merges it with
    PostgreSQL settings from a sibling .env file and OS environment variables,
    following a well-defined precedence controlled by
    ``user_environment_db_config`` (default True).

    Args:
        path: Path to the YAML configuration file.

    Returns:
        An ``AppConfig`` instance populated with validated settings.

    Raises:
        FileNotFoundError: If the configuration file does not exist.
        ValueError: If required fields are missing or inconsistent.
    """
    base_dir = path.parent
    raw = _read_yaml(path)

    # Determine precedence flag (default: environment first)
    prefer_env = _ensure_bool(raw.get("user_environment_db_config", True), "user_environment_db_config")

    # Load environment variables: prefer repo-root .env (search upward), fallback to local .env
    env_path = _find_env_file(base_dir) or (base_dir / ".env")
    dotenv_vars = _parse_dotenv(env_path)
    os_vars = {k: v for k, v in os.environ.items() if k.startswith("POSTGRES_")}
    merged_env = {**dotenv_vars, **os_vars}
    env_cfg = _env_to_config_keys(merged_env)

    # YAML values (may be None or empty strings)
    yaml_db_host = _get_optional_str(raw, "db_host")
    yaml_db_port = _get_optional_str(raw, "db_port")
    yaml_db_user = _get_optional_str(raw, "db_user")
    yaml_db_password = _get_optional_str(raw, "db_password")
    yaml_db_name = _get_optional_str(raw, "db_name")
    yaml_results_table = _get_optional_str(raw, "results_table")
    yaml_auth_db_schema = _get_optional_str(raw, "auth_db_schema", default="public")
    yaml_app_user_table = _get_optional_str(raw, "app_user_table", default="users")

    def choose(yaml_val: Optional[str], env_key: str) -> Optional[str]:
        """Resolve a setting by precedence between YAML and environment.

        Args:
            yaml_val (Optional[str]): Value from YAML (may be None or empty).
            env_key (str): Environment-derived config key to consider (already mapped).

        Returns:
            Optional[str]: The chosen non-empty value according to precedence rules, or None.
        """
        env_val = env_cfg.get(env_key)
        if prefer_env:
            return (env_val if (env_val is not None and str(env_val).strip() != "") else yaml_val)
        # YAML-first
        if yaml_val is not None and str(yaml_val).strip() != "":
            return yaml_val
        return env_val if (env_val is not None and str(env_val).strip() != "") else None

    # Resolve DB settings with precedence
    db_host = choose(yaml_db_host, "db_host")
    db_port_raw = choose(yaml_db_port, "db_port")
    db_user = choose(yaml_db_user, "db_user")
    db_password = choose(yaml_db_password, "db_password")
    db_name = choose(yaml_db_name, "db_name")
    results_table = choose(yaml_results_table, "results_table")

    # Auth schema and app user table: environment may only provide table name; schema is always YAML (with default)
    auth_db_schema = (yaml_auth_db_schema or "public").strip()
    app_user_table = (choose(yaml_app_user_table, "app_user_table") or "users").strip()

    if not db_host:
        raise ValueError("Missing required DB config: db_host")
    if not db_port_raw:
        raise ValueError("Missing required DB config: db_port")
    if not db_user:
        raise ValueError("Missing required DB config: db_user")
    if not db_password:
        raise ValueError("Missing required DB config: db_password")
    if not db_name:
        raise ValueError("Missing required DB config: db_name")

    db_port = _get_int_from_any(db_port_raw, "db_port")

    # Core flags
    use_csv = _ensure_bool(raw.get("use_csv", False), "use_csv")

    # Results source specifics
    csv_path = _get_optional_str(raw, "csv_path")

    # Web server settings
    web_port = _get_int_from_any(raw.get("web_port", 8080), "web_port")
    debug_mode = _ensure_bool(raw.get("debug_mode", False), "debug_mode")
    # Security: 2FA toggle (default False)
    enable_2f_authentication = _ensure_bool(raw.get("enable_2F_authentication", False), "enable_2F_authentication")

    # Secret key (generate default if not provided)
    secret_key = _get_optional_str(raw, "secret_key") or _generate_secret_key()

    # Cross-field validation
    if use_csv:
        if not csv_path:
            raise ValueError("'csv_path' must be provided when 'use_csv' is true")
    else:
        if not results_table:
            raise ValueError("'results_table' must be provided when 'use_csv' is false")

    return AppConfig(
        use_csv=use_csv,
        csv_path=csv_path,
        db_host=db_host,
        db_port=db_port,
        db_user=db_user,
        db_password=db_password,
        db_name=db_name,
        results_table=results_table,
        auth_db_schema=auth_db_schema,
        app_user_table=app_user_table,
        web_port=web_port,
        debug_mode=debug_mode,
        secret_key=secret_key,
        user_environment_db_config=prefer_env,
        enable_2f_authentication=enable_2f_authentication,
    )
