# ==============================================================================
#      DUAL-PURPOSE Production & Development Compose File (Debian-based)
# ==============================================================================
# This file defines the application stack for a standard Linux/Debian system.
# It is designed for two primary scenarios:
#
# 1. PRODUCTION (Default): It runs a pre-built, versioned Docker image from a
#    registry. This is secure, repeatable, and ideal for CI/CD pipelines.
#
# 2. DEVELOPMENT: By uncommenting the 'build' section below, you can use this
#    exact same file to build the image locally on your development machine.
#
# --- HOW TO RUN ---
#
# A) PRODUCTION (using a pre-built image from a registry):
#    1. Edit the 'image:' tag to the version you want to deploy.
#    2. docker compose pull
#    3. docker compose --profile postgres up -d
#
# B) DEVELOPMENT (building the image locally):
#    1. Uncomment the 'build:' section in the 'x-app-base' template below.
#    2. docker compose --profile postgres up -d --build

# --- DEPLOYMENT SCENARIOS (Controlled by .env and --profile flags) ---
#
# 1. ALL-IN-ONE (Internal PG, Qdrant, APIs):
#    - .env: Leave all _EXTERNAL variables commented out.
#    - CMD:  docker compose --profile gui --profile fastapi_gui --profile postgres --profile qdrant up -d
#
# 2. FULLY EXTERNAL (Connect to existing PG, Qdrant, APIs):
#    - .env: Set all _EXTERNAL variables to their real addresses.
#    - CMD:  docker compose --profile gui --profile fastapi_gui up -d
#
# 3. HYBRID (e.g., Internal GUI, External everything else):
#    - .env: Set _EXTERNAL variables for PG, Qdrant, and Flask API.
#    - CMD:  docker compose --profile gui up -d
# ==============================================================================

# ==============================================================================
#                      --- TEMPLATE DEFINITIONS (YAML ANCHORS) ---
# ==============================================================================
# This section defines a reusable template for our application services.
# The 'x-' prefix is a standard convention indicating that this is NOT a
# service to be run, just a block of reusable configuration.

x-app-base: &app-base
  # This is a YAML Anchor named 'app-base'. It acts like a bookmark for this
  # entire block of configuration, which we can reuse below.

  # --- DUAL-PURPOSE BUILD/IMAGE STRATEGY ---
  #
  # FOR PRODUCTION (Default): Keep the 'build' section commented out. Docker
  # Compose will pull and run the specific 'image' defined below from a registry.
  #
  # FOR DEVELOPMENT: Uncomment the 'build' section. Docker Compose will
  # ignore the 'image' key and build an image locally using your primary Dockerfile.
  #
  # build:
  #   context: .
  #   dockerfile: Dockerfile

  # FOR PRODUCTION: The image name MUST be fully qualified with your registry
  # username and a specific version tag.
  # Replace 'tako-user' with your Docker Hub username.
  # Replace 'v1.0.0' with the specific version you are deploying.
  # If you want to interact with the image in docker repos like dockerhub, etc use name for example: jeebu-user/jk-image-similarity-app:v1.0.0
  image: jk-image-similarity-app:v1.0.0   
  restart: unless-stopped
  env_file: .env
  volumes:
    # --- Volume Strategy for the Application ---

    # METHOD 1: PRODUCTION (Recommended)
    # Using named volumes for runtime data is safer and more portable.
    # Mounts the 'configs' directory as read-only for security.
    - ./configs:/home/appuser/app/configs:ro
    # Uses named volumes for dynamic data, managed by Docker.
    - downloads_data:/home/appuser/app/downloads
    - instance_data:/home/appuser/app/instance
    - logs_data:/home/appuser/app/logs

    # --------------------------------------------------------------------------
    # METHOD 2: DEVELOPMENT / ALTERNATIVE (Commented Out)
    # In a development scenario, you might prefer to use bind mounts to see
    # generated files directly on your host. To use, comment out METHOD 1 above
    # and uncomment these lines.
    # WARNING: This is less portable and can cause permission issues.
    # - ./downloads:/home/appuser/app/downloads
    # - ./instance:/home/appuser/app/instance
    # - ./logs:/home/appuser/app/logs
    # --------------------------------------------------------------------------

  # ============================================================================
  # --- ⭐ GPU ACCELERATION CONFIGURATION (NEWLY ADDED) ⭐ ---
  # ============================================================================
  # This block grants the container access to the host's NVIDIA GPU.
  # It will only work if the NVIDIA Container Toolkit is installed on the host.
  # If you run this on a machine without a GPU, Docker Compose will return an error.
  deploy:
    resources:
      reservations:
        devices:
          - driver: nvidia
            count: all
            capabilities: [gpu]
  # ============================================================================
  environment:
    # --- DYNAMIC HOST & MODE CONFIGURATION ---
    # This section dynamically sets the hostnames for the databases.
    # It reads variables from your .env file. If the variables are not set
    # in .env, it falls back to the default internal service names.
    # This allows you to switch between internal and external databases
    # without ever touching this file again.
    #
    # ⭐ To use an EXTERNAL Postgres server, set POSTGRES_HOST_EXTERNAL in .env.
    # ⭐ To use an EXTERNAL Qdrant server, set QDRANT_HOST_EXTERNAL in .env.
    #
    # The ":- <default>" syntax means: "Use the value of the variable on the left,
    # but if it is empty or unset, use the default value on the right."
    
    # This block makes the file universal. It uses the .env file to decide
    # where to connect. If an _EXTERNAL variable is not set in .env, it
    # falls back to the default internal Docker service name or port.

    # PostgreSQL Overrides
    - POSTGRES_HOST=${POSTGRES_HOST_EXTERNAL:-db}
    - POSTGRES_PORT=${POSTGRES_PORT_EXTERNAL:-5432} # Default internal PG port
    - POSTGRES_USER_HOST=${POSTGRES_HOST_EXTERNAL:-db}
    - POSTGRES_USER_PORT=${POSTGRES_PORT_EXTERNAL:-5432}

    # Qdrant Overrides
    - QDRANT_HOST=${QDRANT_HOST_EXTERNAL:-qdrant}
    - QDRANT_PORT=${QDRANT_PORT_EXTERNAL:-6333} # Default internal Qdrant REST port
    - QDRANT_MODE=${QDRANT_MODE:-server}

# ==============================================================================
#                            --- CORE SERVICES ---
# ==============================================================================
services:
  # --- 1. PostgreSQL Database Service (OPTIONAL) ---
  db:
    profiles: ["postgres"]
    image: postgres:15-alpine
    container_name: postgres_db_prod_service
    restart: unless-stopped
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./postgres-init:/docker-entrypoint-initdb.d
    networks:
      - my-app-network
    env_file: .env 
    environment: 
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_USER_DB_NAME=${POSTGRES_USER_DB}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5

  # --- 2. Qdrant Vector Database Service (OPTIONAL) ---
  qdrant:
    profiles: ["qdrant"]
    image: qdrant/qdrant:v1.9.2
    container_name: qdrant_db_prod_service
    restart: unless-stopped
    ports:
      - "6333:6333"
      - "6334:6334"
    volumes:
      - qdrant_data:/qdrant/storage
    networks:
      - my-app-network
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:6333/healthz || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5

  # --- 3. Flask API Service ---
  flask_api:
    profiles: ["flask_api", "gui"] 
    <<: *app-base
    container_name: flask_api_prod_service
    command: flask-api
    gpus: all
    networks:
      - my-app-network
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:5001/healthz || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    ports:
      - "5001:5001"
    depends_on:
      db:
        condition: service_healthy
      qdrant:
        condition: service_healthy

  # --- 4. FastAPI Service ---
  fastapi_api:
    profiles: ["fastapi_api", "fastapi_gui"]
    <<: *app-base
    container_name: fastapi_api_prod_service
    command: fastapi-api
    gpus: all
    networks:
      - my-app-network
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:8000/healthz || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    ports:
      - "8000:8000"
    depends_on:
      db:
        condition: service_healthy
      qdrant:
        condition: service_healthy

  # --- 5. GUI Service (OPTIONAL) ---
  gui:
    profiles: ["gui"]
    <<: *app-base
    container_name: gui_prod_service
    command: gui
    gpus: all
    networks:
      - my-app-network
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:8501/healthz || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    ports:
      - "8501:8501"
    environment:
      - API_BASE_URL=http://${FLASK_API_HOST_EXTERNAL:-flask_api}:${FLASK_API_PORT_EXTERNAL:-5001}/api/v1
    depends_on:
      db:
        condition: service_healthy
      qdrant:
        condition: service_healthy
      flask_api:
        condition: service_started
      

  # --- 6. FastAPI GUI Service ---
  fastapi_gui:
    profiles: ["fastapi_gui"]
    <<: *app-base
    container_name: fastapi_gui_prod_service
    command: fastapi-gui
    gpus: all
    networks:
      - my-app-network
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:8501/healthz || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    ports:
      - "8502:8502"
    environment:
      - API_BASE_URL=http://${FASTAPI_API_HOST_EXTERNAL:-fastapi_api}:${FASTAPI_API_PORT_EXTERNAL:-8000}/api/v1
    depends_on:
      db:
        condition: service_healthy
      qdrant:
        condition: service_healthy
      fastapi_api:
        condition: service_started
        
  # --- 7. CLI Helper Service (CLI Only) ---
  cli_runner:
    profiles: ["cli"]
    <<: *app-base
    gpus: all
    networks:
      - my-app-network
    depends_on:
      db:
        condition: service_healthy
      qdrant:
        condition: service_healthy

# ==============================================================================
#                      --- NAMED VOLUME DEFINITIONS ---
# ==============================================================================
volumes:
  postgres_data:
  qdrant_data:
  downloads_data:
  instance_data:
  logs_data:

# ==============================================================================
#                  --- TOP-LEVEL NETWORK & VOLUME DEFINITIONS ---
# ==============================================================================
networks:
  my-app-network:
    name: my-app-network
    driver: bridge
