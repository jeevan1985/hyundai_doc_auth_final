# ==============================================================================
#      DUAL-PURPOSE Production & Development Compose File (Debian-based)
# ==============================================================================
# This file defines the application stack for a standard Linux/Debian system.
# It is designed for two primary scenarios:
#
# 1. PRODUCTION (Default): It runs a pre-built, versioned Docker image from a
#    registry. This is secure, repeatable, and ideal for CI/CD pipelines.
#
# 2. DEVELOPMENT: By uncommenting the 'build' section below, you can use this
#    exact same file to build the image locally on your development machine.
#
# --- HOW TO RUN ---
#
# A) PRODUCTION (using a pre-built image from a registry):
#    1. Edit the 'image:' tag to the version you want to deploy.
#    2. docker-compose pull
#    3. docker-compose --profile postgres up -d
#
# B) DEVELOPMENT (building the image locally):
#    1. Uncomment the 'build:' section in the 'x-app-base' template below.
#    2. docker-compose --profile postgres up -d --build

# --- DEPLOYMENT SCENARIOS (Controlled by .env and --profile flags) ---
#
# 1. ALL-IN-ONE (Internal PG, Qdrant, APIs):
#    - .env: Leave all _EXTERNAL variables commented out.
#    - CMD:  docker-compose --profile gui --profile fastapi_gui --profile postgres --profile qdrant up -d
#
# 2. FULLY EXTERNAL (Connect to existing PG, Qdrant, APIs):
#    - .env: Set all _EXTERNAL variables to their real addresses.
#    - CMD:  docker-compose --profile gui --profile fastapi_gui up -d
#
# 3. HYBRID (e.g., Internal GUI, External everything else):
#    - .env: Set _EXTERNAL variables for PG, Qdrant, and Flask API.
#    - CMD:  docker-compose --profile gui up -d
# ==============================================================================

# ==============================================================================
#                      --- TEMPLATE DEFINITIONS (YAML ANCHORS) ---
# ==============================================================================
# This section defines a reusable template for our application services.
# The 'x-' prefix is a standard convention indicating that this is NOT a
# service to be run, just a block of reusable configuration.

x-app-base: &app-base
  # This is a YAML Anchor named 'app-base'. It acts like a bookmark for this
  # entire block of configuration, which we can reuse below.

  # --- DUAL-PURPOSE BUILD/IMAGE STRATEGY ---
  #
  # FOR PRODUCTION (Default): Keep the 'build' section commented out. Docker
  # Compose will pull and run the specific 'image' defined below from a registry.
  #
  # FOR DEVELOPMENT: Uncomment the 'build' section. Docker Compose will
  # ignore the 'image' key and build an image locally using your primary Dockerfile.
  #
  # build:
  #   context: .
  #   dockerfile: Dockerfile.conda

  # FOR PRODUCTION: The image name MUST be fully qualified with your registry
  # username and a specific version tag.
  # Replace 'tako-user' with your Docker Hub username.
  # Replace 'v1.0.0' with the specific version you are deploying.
  # If you want to interact with the image in docker repos like dockerhub, etc use name for example: jeebu-user/jk-image-similarity-app:v1.0.0
  image: jk-image-similarity-app:v1.0.0   
  restart: unless-stopped
  env_file: .env
  volumes:
    # --- Volume Strategy for the Application ---

    # METHOD 1: PRODUCTION (Recommended)
    # Using named volumes for runtime data is safer and more portable.
    # Mounts the 'configs' directory as read-only for security.
    - ./configs:/home/appuser/app/configs:ro
    # Uses named volumes for dynamic data, managed by Docker.
    - ./appdata/downloads:/home/appuser/app/downloads
    - ./appdata/instance:/home/appuser/app/instance
    - ./applog:/home/appuser/app/logs

    # --------------------------------------------------------------------------
    # METHOD 2: DEVELOPMENT / ALTERNATIVE (Commented Out)
    # In a development scenario, you might prefer to use bind mounts to see
    # generated files directly on your host. To use, comment out METHOD 1 above
    # and uncomment these lines.
    # WARNING: This is less portable and can cause permission issues.
    # - ./downloads:/home/appuser/app/downloads
    # - ./instance:/home/appuser/app/instance
    # - ./logs:/home/appuser/app/logs
    # --------------------------------------------------------------------------

  # ============================================================================
  # --- ⭐ GPU ACCELERATION CONFIGURATION (NEWLY ADDED) ⭐ ---
  # ============================================================================
  # This block grants the container access to the host's NVIDIA GPU.
  # It will only work if the NVIDIA Container Toolkit is installed on the host.
  # If you run this on a machine without a GPU, Docker Compose will return an error.
  deploy:
    resources:
      reservations:
        devices:
          - driver: nvidia
            count: all
            capabilities: [gpu]
  # ============================================================================
  environment:
    # --- DYNAMIC HOST & MODE CONFIGURATION ---
    # This section dynamically sets the hostnames for the databases.
    # It reads variables from your .env file. If the variables are not set
    # in .env, it falls back to the default internal service names.
    # This allows you to switch between internal and external databases
    # without ever touching this file again.
    #
    # ⭐ To use an EXTERNAL Postgres server, set POSTGRES_HOST_EXTERNAL in .env.
    # ⭐ To use an EXTERNAL Qdrant server, set QDRANT_HOST_EXTERNAL in .env.
    #
    # The ":- <default>" syntax means: "Use the value of the variable on the left,
    # but if it is empty or unset, use the default value on the right."
    
    # This block makes the file universal. It uses the .env file to decide
    # where to connect. If an _EXTERNAL variable is not set in .env, it
    # falls back to the default internal Docker service name or port.

    # PostgreSQL Overrides
    - POSTGRES_HOST=${POSTGRES_HOST_EXTERNAL:-db}
    - POSTGRES_PORT=${POSTGRES_PORT_EXTERNAL:-5432} # Default internal PG port
    - POSTGRES_USER_HOST=${POSTGRES_HOST_EXTERNAL:-db}
    - POSTGRES_USER_PORT=${POSTGRES_PORT_EXTERNAL:-5432}

    # Qdrant Overrides
    - QDRANT_HOST=${QDRANT_HOST_EXTERNAL:-qdrant}
    - QDRANT_PORT=${QDRANT_PORT_EXTERNAL:-6333} # Default internal Qdrant REST port
    - QDRANT_MODE=${QDRANT_MODE:-server}
    - APP_LOG_DIR=/home/appuser/app/logs

# ==============================================================================
#                            --- CORE SERVICES ---
# ==============================================================================
services:
  app_scheduler:
    <<: *app-base
    container_name: app_scheduler_service_gpu
    gpus: all
    # Uses the image default CMD (scheduler via entrypoint default)
    networks:
      - my-app-network
    depends_on:
      db:
        condition: service_healthy
      qdrant:
        condition: service_healthy

  # --- 1. PostgreSQL Database Service (OPTIONAL) ---
  db:
    # 'profiles: ["postgres"]' makes this service optional. It will only start
    # if you run docker-compose with the '--profile postgres' flag.
    profiles: ["postgres"]
    image: postgres:15-alpine
    container_name: postgres_db_prod_service
    restart: unless-stopped
    volumes:
      - ./appdata/postgres:/var/lib/postgresql/data
      - ./hyundai_document_authenticator/postgres-init:/docker-entrypoint-initdb.d
    # ⭐ Connect this service to our custom application network.
    networks:
      - my-app-network
    env_file: .env 
    # --- Environment variables specific to the PostgreSQL container ---
    # This uses the consistent list syntax to avoid YAML parsing errors.
    environment: 
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_USER_DB_NAME=${POSTGRES_USER_DB}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5

  # --- 2. Qdrant Vector Database Service (NOW OPTIONAL) ---
  qdrant:
    # ⭐ CHANGE 1: This service is now in a profile. It will only start if you
    # run docker-compose with the '--profile qdrant' flag. This allows you
    # to easily disable it if you are using an external Qdrant server.
    profiles: ["qdrant"]
    # ⭐ CHANGE 2: You can also use the CPU-compatible image to prevent healthcheck failures
    # on machines without AVX2 support. You can easily switch back to the standard
    # image if you are on a compatible modern CPU.
    image: qdrant/qdrant:v1.9.2
    container_name: qdrant_db_prod_service
    restart: unless-stopped
    ports:
      # You can change the host port (left side) if it conflicts.
      # e.g., "7333:6333"
      - "6333:6333"
      - "6334:6334"
    volumes:
      - ./appdata/qdrant:/qdrant/storage
    # ⭐ Connect this service to our custom application network.
    networks:
      - my-app-network
    healthcheck:
      # ⭐ CHANGE 3: Using the more robust /healthz endpoint for the check.
      test: ["CMD-SHELL", "curl -f http://localhost:6333/healthz || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5

  # --- 3. Flask API Service ---
  flask_api:
    # ⭐ This service is now optional, part of the 'flask_api' profile.
    profiles: ["flask_api", "gui"] 
    <<: *app-base
    container_name: flask_api_prod_service
    command: flask-api
    gpus: all
    # ⭐ Connect this service to our custom application network.
    networks:
      - my-app-network
    # We override the test command specifically for this service's port
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:5001/healthz || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    ports:
      - "5001:5001"
    depends_on:
      db:
        condition: service_healthy
        # required: false
      qdrant:
        # ⭐ CHANGE 4: The dependency is now optional. If the 'qdrant' profile is
        # not active, this service will start without waiting for it.
        condition: service_healthy
        # required: false

  # --- 4. FastAPI Service ---
  fastapi_api:
    # ⭐ This service is now optional, part of the 'fastapi_api' profile.
    profiles: ["fastapi_api", "fastapi_gui"]
    <<: *app-base
    container_name: fastapi_api_prod_service
    command: fastapi-api
    gpus: all
    # ⭐ Connect this service to our custom application network.
    networks:
      - my-app-network
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:8000/healthz || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    ports:
      - "8000:8000"
    depends_on:
      db:
        condition: service_healthy
        # required: false
      qdrant:
        # ⭐ Repeat the change for all services that depend on Qdrant.
        condition: service_healthy
        # required: false

  # --- 5. GUI Service (OPTIONAL) ---
  gui:
    # ⭐ This service is now optional, part of the 'gui' profile.
    profiles: ["gui"]
    <<: *app-base
    container_name: gui_prod_service
    command: gui
    gpus: all
    # ⭐ Connect this service to our custom application network.
    networks:
      - my-app-network
    # ADDED a healthcheck
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:8501/healthz || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    ports:
      - "8501:8501"
    environment:
      # This now dynamically constructs the URL using both host and port overrides.
      - API_BASE_URL=http://${FLASK_API_HOST_EXTERNAL:-flask_api}:${FLASK_API_PORT_EXTERNAL:-5001}/api/v1
    depends_on:
      db:
        condition: service_healthy
        # required: false
      qdrant:
        # ⭐ Repeat the change here.
        condition: service_healthy
        # required: false
      # ⭐ CRITICAL: Docker Compose is smart. If you enable the 'gui' profile,
      # it will see this dependency and automatically enable the 'flask_api'
      # profile as well. You don't have to specify both!
      flask_api:
        condition: service_started
      

  # --- 6. FastAPI GUI Service ---
  fastapi_gui:
    # ⭐ This service is now optional, part of the 'fastapi_gui' profile.
    profiles: ["fastapi_gui"]
    <<: *app-base
    container_name: fastapi_gui_prod_service
    command: fastapi-gui
    gpus: all
    # ⭐ Connect this service to our custom application network.
    networks:
      - my-app-network
    # ADDED a healthcheck
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:8501/healthz || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    ports:
      - "8502:8502"
    environment:
      - API_BASE_URL=http://${FASTAPI_API_HOST_EXTERNAL:-fastapi_api}:${FASTAPI_API_PORT_EXTERNAL:-8000}/api/v1
    depends_on:
      db:
        condition: service_healthy
        # required: false
      qdrant:
        condition: service_healthy
        # required: false
      # Enabling the 'fastapi_gui' profile will automatically start 'fastapi_api'.
      fastapi_api:
        condition: service_started
        
  # --- 7. CLI Helper Service (NEW - FOR CLI ONLY) ---
  # This is a "dummy" service. It uses the same application image but has no
  # command and is never meant to be run permanently. Its only purpose is to
  # provide a clean target for `docker-compose run` commands that may need
  # database connections without starting a full API server.
  cli_runner:
    profiles: ["cli"] # It has its own profile, so it never starts by default.
    <<: *app-base
    gpus: all
    # ⭐ Connect this service to our custom application network.
    networks:
      - my-app-network
    depends_on:
      db:
        condition: service_healthy
        # required: false
      qdrant:
        condition: service_healthy
        # required: false

# ==============================================================================
#                      --- NAMED VOLUME DEFINITIONS ---
# ==============================================================================
# This section formally declares the named volumes used by the services.
# Docker will manage the storage for these volumes, ensuring data persists
# even when containers are removed and recreated.

# ==============================================================================
#                  --- TOP-LEVEL NETWORK & VOLUME DEFINITIONS ---
# ==============================================================================
# ⭐ This defines the single, private network that all services will share.
# ⭐ It allows containers to find and talk to each other using their service names.
networks:
  my-app-network:
    name: my-app-network
    driver: bridge