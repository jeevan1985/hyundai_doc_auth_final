# ==============================================================================
#      DUAL-PURPOSE Production & Development Compose File for RHEL
# ==============================================================================
# This file defines the application stack for a Red Hat Enterprise Linux (RHEL)
# or compatible system (e.g., CentOS, Rocky Linux).
#
# Key RHEL-specific features:
#   - Uses RHEL-standard paths (e.g., /opt/app-root/src).
#   - Includes the ':z' flag on bind mounts for SELinux compatibility.
#   - Uses RHEL-specific names for containers and volumes to avoid conflicts.
#
# --- DEPLOYMENT SCENARIOS (Controlled by .env and --profile flags) ---
#
# 1. ALL-IN-ONE (Internal PG, Qdrant, APIs):
#    - .env: Leave all _EXTERNAL variables commented out.
#    - CMD:  docker-compose -f docker-compose.rhel.yml --profile gui --profile fastapi_gui --profile postgres --profile qdrant up -d
#
# 2. FULLY EXTERNAL (Connect to existing PG, Qdrant, APIs):
#    - .env: Set all _EXTERNAL variables to their real addresses.
#    - CMD:  docker-compose -f docker-compose.rhel.yml --profile gui --profile fastapi_gui up -d
# ==============================================================================

# ==============================================================================
#                      --- TEMPLATE DEFINITIONS (YAML ANCHORS) ---
# ==============================================================================
# This section defines a reusable template for our application services.
# The 'x-' prefix is a standard convention indicating that this is NOT a
# service to be run, just a block of reusable configuration.

x-app-base: &app-base
  # This is a YAML Anchor named 'app-base'. It acts like a bookmark for this
  # entire block of configuration, which we can reuse below.

  # --- DUAL-PURPOSE BUILD/IMAGE STRATEGY ---
  #
  # FOR DEVELOPMENT: Uncomment the 'build' section. Docker Compose will
  # ignore the 'image' key and build an image locally using your Dockerfile.rhel.
  # build:
  #   context: .
  #   dockerfile: Dockerfile.rhel
  image: tako-user/jk-image-similarity-app:rhel-v1.0.0
  restart: unless-stopped
  env_file: .env
  volumes:
    # --- Volume Strategy for RHEL ---
    # The internal container paths are set to the RHEL standard '/opt/app-root/src'.
    # 🔒 The ':z' flag is CRITICAL for RHEL. It tells Docker to apply the correct
    # SELinux security label to the host directory, allowing the container's
    # processes to access it without being blocked by SELinux policies.
    - ./configs:/opt/app-root/src/configs:ro,z
    - downloads_data_rhel:/opt/app-root/src/downloads
    - instance_data_rhel:/opt/app-root/src/instance
    - logs_data_rhel:/opt/app-root/src/logs
  environment:
    # --- DYNAMIC HOST & MODE CONFIGURATION ---
    # This section dynamically sets the hostnames for the databases.
    # It reads variables from your .env file. If the variables are not set
    # in .env, it falls back to the default internal service names.
    # This allows you to switch between internal and external databases
    # without ever touching this file again.
    # The ":- <default>" syntax means: "Use the value of the variable on the left,
    # but if it is empty or unset, use the default value on the right."
    # This block makes the file universal. It uses the .env file to decide
    # where to connect. If an _EXTERNAL variable is not set in .env, it
    # falls back to the default internal Docker service name or port.
    
    # PostgreSQL Overrides
    - POSTGRES_HOST=${POSTGRES_HOST_EXTERNAL:-db}
    - POSTGRES_PORT=${POSTGRES_PORT_EXTERNAL:-5432}
    - POSTGRES_USER_HOST=${POSTGRES_HOST_EXTERNAL:-db}
    - POSTGRES_USER_PORT=${POSTGRES_PORT_EXTERNAL:-5432}

    # Qdrant Overrides
    - QDRANT_HOST=${QDRANT_HOST_EXTERNAL:-qdrant}
    - QDRANT_PORT=${QDRANT_PORT_EXTERNAL:-6333}
    - QDRANT_MODE=${QDRANT_MODE:-server}

# ==============================================================================
#                            --- CORE SERVICES ---
# ==============================================================================
services:
  app_scheduler:
    <<: *app-base
    container_name: app_scheduler_rhel_service
    # Uses the image default CMD (scheduler via entrypoint default)
    networks:
      - my-rhel-app-network
    depends_on:
      db:
        condition: service_healthy
        required: false
      qdrant:
        condition: service_healthy
        required: false

  # --- 1. PostgreSQL Database Service (OPTIONAL) ---
  db:
    # 'profiles: ["postgres"]' makes this service optional. It will only start
    # if you run docker-compose with the '--profile postgres' flag.
    profiles: ["postgres"]
    image: postgres:15-alpine
    container_name: postgres_db_rhel_prod_service
    restart: unless-stopped
    volumes:
      - postgres_data_rhel:/var/lib/postgresql/data:z
      # The ':z' flag is required here as well for the init script mount.
      - ../postgres-init:/docker-entrypoint-initdb.d:z
    # ⭐ Connect this service to our custom application network.
    networks:
      - my-rhel-app-network
    env_file: .env
    environment:
      # Maps variables from your .env file to the names the Postgres image needs.
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_USER_DB_NAME: ${POSTGRES_USER_DB}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5

  # --- 2. Qdrant Vector Database Service (NOW OPTIONAL) ---
  qdrant:
    # ⭐ This service is now in a profile. It will only start if you run
    # docker-compose with the '--profile qdrant' flag. This allows you to
    # easily disable it if you are using an external Qdrant server.
    profiles: ["qdrant"]
    # ⭐ Using the CPU-compatible image to prevent healthcheck failures on
    # machines without AVX2 support. You can switch back to the standard
    # image if you are on a compatible modern CPU.
    image: qdrant/qdrant:v1.9.1-avx-disabled
    container_name: qdrant_db_rhel_prod_service
    restart: unless-stopped
    ports:
      - "6333:6333"
      - "6334:6334"
    volumes:
      - qdrant_data_rhel:/qdrant/storage
    # ⭐ Connect this service to our custom application network.
    networks:
      - my-rhel-app-network
    healthcheck:
      # ⭐ Using the more robust /healthz endpoint for the check.
      test: ["CMD-SHELL", "curl -f http://localhost:6333/healthz || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5

  # --- 3. Flask API Service (OPTIONAL) ---
  flask_api:
    profiles: ["flask_api"] 
    # '<<: *app-base' is a YAML Alias. It means "copy everything from the &app-base
    # bookmark and paste it here". This inherits all our common configurations.
    <<: *app-base
    container_name: flask_api_rhel_prod_service
    command: flask-api    # Overrides the default CMD to run the Flask API.
    # ⭐ Connect this service to our custom application network.
    networks:
      - my-rhel-app-network
    # We override the test command specifically for this service's port
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:5001/healthz || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    ports:
      - "5001:5001"
    depends_on:
      db:
        condition: service_healthy
        required: false
      qdrant:
        # ⭐ The dependency is now optional. If the 'qdrant' profile is not
        # active, this service will start without waiting for it.
        condition: service_healthy
        required: false

  # --- 4. FastAPI Service (OPTIONAL) ---
  fastapi_api:
    profiles: ["fastapi_api"]
    <<: *app-base          # Reuse the base template.
    container_name: fastapi_api_rhel_prod_service
    command: fastapi-api  # Run the FastAPI server.
    # ⭐ Connect this service to our custom application network.
    networks:
      - my-rhel-app-network
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:8000/healthz || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    ports:
      - "8000:8000"
    depends_on:
      db:
        condition: service_healthy
        required: false
      qdrant:
        # ⭐ Repeat the change for all services that depend on Qdrant.
        condition: service_healthy
        required: false

  # --- 5. GUI Service (OPTIONAL, for Flask API) ---
  gui:
    profiles: ["gui"]
    <<: *app-base
    container_name: gui_rhel_prod_service
    command: gui
    # ⭐ Connect this service to our custom application network.
    networks:
      - my-rhel-app-network
    # ADDED a healthcheck
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:8501/healthz || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    ports:
      - "8501:8501"
    environment:
      # We can add or override variables on top of the base template.
      - API_BASE_URL=http://${FLASK_API_HOST_EXTERNAL:-flask_api}:${FLASK_API_PORT_EXTERNAL:-5001}/api/v1
    depends_on:
      db:
        condition: service_healthy
        required: false
      qdrant:
        # ⭐ Repeat the change here.
        condition: service_healthy
        required: false
      # This dependency is now optional. Enabling the 'gui' profile will intelligently
      # start the 'flask_api' service if its profile is also active.
      flask_api:
        condition: service_started
        required: false

  # --- 6. FastAPI GUI Service (OPTIONAL, for FastAPI) ---
  fastapi_gui:
    profiles: ["fastapi_gui"]
    <<: *app-base
    container_name: fastapi_gui_rhel_prod_service
    command: fastapi-gui
    # ⭐ Connect this service to our custom application network.
    networks:
      - my-rhel-app-network
    # ADDED a healthcheck
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:8501/healthz || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    ports:
      - "8502:8502"
    environment:
      # This now dynamically sets the API URL for the FastAPI stack.
      - API_BASE_URL=http://${FASTAPI_API_HOST_EXTERNAL:-fastapi_api}:${FASTAPI_API_PORT_EXTERNAL:-8000}/api/v1
    depends_on:
      db:
        condition: service_healthy
        required: false
      qdrant:        
        condition: service_healthy
        required: false
      # This dependency correctly points to the 'fastapi_api' service and is optional.
      fastapi_api:
        condition: service_started
        required: false
        
  # --- 7. CLI Helper Service ---
  cli_runner:
    profiles: ["cli"] 
    <<: *app-base
    container_name: cli_runner_rhel_service
    # ⭐ Connect this service to our custom application network.
    networks:
      - my-rhel-app-network
    depends_on:
      db:
        condition: service_healthy
        required: false
      qdrant:
        condition: service_healthy
        required: false

# ==============================================================================
#                             Named Volumes for RHEL
# ==============================================================================
# Define RHEL-specific named volumes to avoid conflicts with other environments
# if they are ever run on the same Docker host.
volumes:
  postgres_data_rhel:
  qdrant_data_rhel:
  downloads_data_rhel:
  instance_data_rhel:
  logs_data_rhel:

# ==============================================================================
#                    --- RHEL Application Network ---
# ==============================================================================
# ⭐ This defines the single, private network that all services will share.
# ⭐ It allows containers to find and talk to each other using their service names.
networks:
  my-rhel-app-network:
    name: my-rhel-app-network
    driver: bridge